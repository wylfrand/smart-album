package com.mycompany.smartalbum.back.controller.restCalls;import java.io.File;import java.io.IOException;import java.util.Iterator;import java.util.LinkedList;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.SessionAttributes;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import com.fasterxml.jackson.core.JsonGenerationException;import com.fasterxml.jackson.databind.JsonMappingException;import com.mycompany.database.smartalbum.exception.PhotoAlbumException;import com.mycompany.database.smartalbum.model.Image;import com.mycompany.database.smartalbum.model.User;import com.mycompany.database.smartalbum.search.enums.MessageHTMLTypes;import com.mycompany.filesystem.model.FileMeta;import com.mycompany.filesystem.utils.Constants;import com.mycompany.filesystem.utils.FileFilter;import com.mycompany.services.utils.Constant;import com.mycompany.services.utils.Pagination;import com.mycompany.services.utils.RetourReponse;import com.mycompany.smartalbum.back.controller.ABaseController;@RestController@RequestMapping("/controllerRest")@SessionAttributes(value = { Constant.SMARTALBUM_ALBUM_FORM,		Constant.MENU_CURRENT_PAGE_ATTR, Constant.SMARTALBUM_PHOTOS_CONTROLLER })public class FileUploadControllerRestCalls extends ABaseController {	private final static transient Logger log = LoggerFactory			.getLogger(FileUploadControllerRestCalls.class);	/***************************************************	 * URL: /controller/upload upload(): receives files	 * 	 * @param request	 *            : MultipartHttpServletRequest auto passed	 * @param response	 *            : HttpServletResponse auto passed	 * @return LinkedList<FileMeta> as json format	 * @throws IOException 	 * @throws JsonMappingException 	 * @throws JsonGenerationException 	 ****************************************************/	@RequestMapping(value = "/upload", method = RequestMethod.POST)	public @ResponseBody LinkedList<FileMeta> upload(			MultipartHttpServletRequest request, HttpServletResponse response) {		// 1. build an iterator		Iterator<String> itr = request.getFileNames();		MultipartFile mpf = null;		String userLogin = backService.getCurrentUser(true).getLogin();		int nbFiles = 0;		// 2. get each file		while (itr.hasNext()) {			// 2.1 get next MultipartFile			mpf = request.getFile(itr.next());			log.debug(mpf.getOriginalFilename() + " uploaded! " + mpf.getSize());			// 2.2 if files > 10 remove the first from the list			saveUnClassifiedImage(mpf, userLogin, nbFiles);					}		// result will be like this		ModelMap model = new ModelMap();		model.put(Constant.SMARTALBUM_PHOTOS_CONTROLLER,				Constant.SMARTALBUM_PHOTOS_FILEUPLOADCONTROLLER);		return tmpFilesToUpload;	}	private synchronized void saveUnClassifiedImage(MultipartFile mpf, String userLogin, int nbFiles) {		// 2.3 create new fileMeta		FileMeta fileMeta = backService.getFileUploadService().computeFileMetaBeforeSavingOriginal(				mpf, userLogin, true);		// 2.4 add to files		fileMeta.setIndexInMemory(new Long(nbFiles++));		String tmpPath = Constants.TMP_DIR + userLogin;		String relativePath = fileMeta.getFileName();		fileMeta.setRelativePath(relativePath);				// On va sauvegardr l'image parmis les fichiers non enregistr√©s de l'utilisateur		try {			User currentUser = backService.getCurrentUser(false);			Image image = backService.getFileUploadService().constructImage(fileMeta);						// On rajoute un message court			backService.addHTMLMessageInNewTmpImage(currentUser, image, MessageHTMLTypes.SHORTDESCRIPTION, "NON INITIALISER");						// On rajoute un message long			backService.addHTMLMessageInNewTmpImage(currentUser, image, MessageHTMLTypes.LONGDESCRIPTION, "DESCRIPTION LONGUE NON INITIALISEE");			fileMeta.setBytes(null);		} catch (PhotoAlbumException e) {			log.error("Une erreur est survenue pendant la sauvegarde de l'image",e);		}				tmpFilesToUpload.add(fileMeta);		backService.getCacheManager().putObjectInCache(Constant.SMARTALBUM_TMP_UPLOADEDPICTURES,tmpFilesToUpload);		if (!backService.getFileSystemService().addImage(				tmpPath + File.separator + fileMeta.getFileName(),				tmpPath + File.separator + fileMeta.getFileName(), false)) {		}	}	@RequestMapping(value = "/deleteFileByName/{value}", method = RequestMethod.POST)	public @ResponseBody RetourReponse deleteFileByName(HttpServletResponse response,@PathVariable String fileName,ModelMap model) {				RetourReponse result = new RetourReponse();		if (StringUtils.isNotBlank(fileName)) {			String userLogin = backService.getCurrentUser(true).getLogin();			FileFilter filter = new FileFilter();			backService.getFileSystemService().deleteImage(File.separator + userLogin + File.separator					+ filter.getNameWithoutExtension(fileName), false);			result.setResult(true);		}		return result;	}	@Override	protected Logger getLoger() {		return log;	}}